# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MVlnBHse8RbpxiWo8oHlh6_4f0Rs_VLv
"""

# Step 1: Install dependencies
!pip install fastapi uvicorn pyngrok yfinance pandas-ta numpy pandas matplotlib seaborn requests nltk newsapi-python

# Step 2: Import libraries
import nest_asyncio
import uvicorn
from pyngrok import ngrok
from fastapi import FastAPI
import yfinance as yf
import pandas as pd
import numpy as np
import requests
import nltk
import io
from newsapi import NewsApiClient
from datetime import datetime, timedelta
from nltk.sentiment import SentimentIntensityAnalyzer

# Initialize NLP components
nltk.download('vader_lexicon')
sia = SentimentIntensityAnalyzer()

# Step 3: Define RobustMFComparator Class
class RobustMFComparator:
    def __init__(self):
        self.price_range_percent = 0.2  # 20% price range
        self.history_years = 3
        self.newsapi = NewsApiClient(api_key='a25048dfabaa47baa872c8fe4118d375')
        self.alpha_vantage_key = 'BZ8YS1TOCO2OZ6E1'
        self.etf_list = self._get_api_etf_list()

    def _get_api_etf_list(self):
        try:
            url = f'https://www.alphavantage.co/query?function=LISTING_STATUS&apikey={self.alpha_vantage_key}&datatype=csv'
            response = requests.get(url)
            if response.status_code != 200:
                return []
            content = response.content.decode('utf-8')
            df = pd.read_csv(io.StringIO(content))
            etfs = [row['symbol'].strip() for _, row in df[df['assetType'] == 'ETF'].iterrows() if self._is_valid_symbol(row['symbol'])]
            return list(dict.fromkeys(etfs))[:300]
        except:
            return []

    def _is_valid_symbol(self, symbol):
        return isinstance(symbol, str) and 2 <= len(symbol) <= 6 and symbol.isalpha()

    def _get_fund_data(self, ticker):
        try:
            data = yf.Ticker(ticker).history(period=f'{self.history_years}y')
            return data['Close'].rename(ticker) if not data.empty else None
        except:
            return None

    def _get_sentiment(self, ticker):
        try:
            news = self.newsapi.get_everything(q=ticker, from_param=(datetime.now() - timedelta(days=3)).strftime('%Y-%m-%d'), language='en', sort_by='relevancy')
            scores = [sia.polarity_scores(f"{article.get('title', '')}. {article.get('description', '')}")['compound'] for article in news.get('articles', [])[:5]]
            return np.mean(scores) if scores else 0
        except:
            return 0

    def _get_sentiment_recommendation(self, score):
        if score >= 0.2:
            return 'Strong Buy'
        elif score >= 0.05:
            return 'Buy'
        elif score <= -0.2:
            return "Strong Sell"
        elif score <= -0.05:
            return "Sell"
        else:
            return 'Neutral'

    def compare(self, mf_ticker):
        try:
            mf_series = self._get_fund_data(mf_ticker)
            if mf_series is None or len(mf_series) < 100:
                return {"error": f"Insufficient data for {mf_ticker}"}

            mf_price = mf_series.iloc[-1]
            price_range = mf_price * self.price_range_percent
            mf_sentiment = self._get_sentiment(mf_ticker)

            results = []
            for etf in self.etf_list:
                etf_data = yf.Ticker(etf).history(period=f'{self.history_years}y')
                if etf_data.empty or len(etf_data) < 100:
                    continue
                etf_price = etf_data['Close'].iloc[-1]
                if abs(etf_price - mf_price) > price_range:
                    continue
                corr = mf_series.corr(etf_data['Close'])
                etf_sentiment = self._get_sentiment(etf)
                total_score = (corr*0.6) + (1 - abs(mf_sentiment - etf_sentiment))*0.4
                results.append({'ETF': etf, 'Price': etf_price, 'Correlation': corr, 'Sentiment': self._get_sentiment_recommendation(etf_sentiment), 'Total_Score': total_score})

            return sorted(results, key=lambda x: x['Total_Score'], reverse=True)[:10]
        except Exception as e:
            return {"error": str(e)}

# Step 4: Setup ngrok
NGROK_AUTH_TOKEN = "2sRjNchz6gPazWeFv2vfpuqawbT_vnceYfFN7R3J4Y8cT48V"
ngrok.set_auth_token(NGROK_AUTH_TOKEN)
public_url = ngrok.connect(8000)
print(f"Ngrok Tunnel URL: {public_url}")

# Step 5: Initialize FastAPI
app = FastAPI()

from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # ðŸ”¥ Allow all origins (Ya specific frontend domain add karo)
    allow_credentials=True,
    allow_methods=["*"],  # ðŸ”¥ All HTTP methods allow
    allow_headers=["*"],  # ðŸ”¥ All headers allow
)

comparator = RobustMFComparator()

@app.get("/compare/{mf_ticker}")
def compare(mf_ticker: str):
    return comparator.compare(mf_ticker)

# Step 6: Run FastAPI in Colab
nest_asyncio.apply()
uvicorn.run(app, host="0.0.0.0", port=8000)

